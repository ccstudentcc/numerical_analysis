\documentclass[8pt,aspectratio=169,mathserif]{beamer}		
%设置为 Beamer 文档类型，设置字体为 10pt，长宽比为16:9，数学字体为 serif 风格

%%%%-----导入宏包-----%%%%
\usepackage{zju}			%导入 zju 模板宏包
\usepackage{ctex}			%导入 ctex 宏包，添加中文支持
\usepackage{amsmath,amsfonts,amssymb,bm}   %导入数学公式所需宏包
\usepackage{color}			 %字体颜色支持
\usepackage{graphicx,hyperref,url}
\usepackage{metalogo}
\usepackage{tikz}
\usepackage{longtable}
%% 上文引用的包可按实际情况自行增删
%%%%%%%%%%%%%%%%%%
\usepackage{fontspec}
\usepackage[SlantFont]{xeCJK}
% \setCJKmainfont{Source Han Sans SC}
% \usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage{setspace}
\usepackage{listings}
\newfontfamily\courier{Consolas}
\lstset{
 columns=fixed,       
 numbers=left,                                        % 在左侧显示行号
 numberstyle=\tiny\color{gray},                       % 设定行号格式
 frame=none,                                          % 不显示背景边框
 backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
 keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
 numberstyle=\footnotesize\color{darkgray},           
 commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
 stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
 showstringspaces=false,                              % 不显示字符串中的空格
 language=c++,                                        % 设置语言
 basicstyle=\small\courier
}
% \addbibresource{ref.bib} %BibTeX数据文件及位置
\setbeamerfont{footnote}{size=\tiny} %调整注脚的文字大小

\beamertemplateballitem		%设置 Beamer 主题

\singlespacing

\setlength{\parskip}{1.5em}

%%%%------------------------%%%%%
\catcode`\。=\active         %或者=13
\newcommand{。}{．}				

\title{数值分析 Chapter 1 非线性方程}
\subtitle{编程作业}
%%%%----标题设置


\author[Fan Rui]{
  樊睿\\\medskip
  {\small \url{12435044@zju.edu.cn}} \\
}%%%%----个人信息设置
  
\institute[ZJUMATH]{
  数学科学学院 \\ 
  浙江大学}
%%%%----机构信息

\date[Sep. 18 2024]{
  2024年9月18日}
%%%%----日期信息
  
\begin{document}

\begin{frame}
	\titlepage
\end{frame}				%生成标题页

\begin{frame}
\frametitle{作业 A~D 要求}
    \begin{itemize}
        \item 将非线性方程求解器统一封装为一个抽象类\lstinline|EquationSolver|，并定义虚函数\lstinline|solve|。
        \item 将本章介绍的三种非线性方程解法（二分、牛顿、割线）分别从这个抽象类继承。
        \item 用三种方法分别求解给定的方程。
    \end{itemize}
\end{frame}

\begin{frame}
\frametitle{回顾：虚函数和继承}
我们在《数据结构与算法》课程中学习过虚函数和继承的概念。

如果一个基类的某个成员函数为虚函数（加\lstinline|virtual|修饰），
则这个基类可以继承出子类，在子类中可以重载该虚函数。
这样做的好处是：当定义基类的指针或引用时，
如果它明确指向了某个子类对象，则调用该虚函数时会直接调用子类重载过的虚函数。

如果基类的某个虚成员函数定义为纯虚函数（例如\lstinline|virtual void solve() = 0|），
则不能直接定义该类的对象，只能定义由它继承的类的对象。

具体语法可详见c++官网\url{https://en.cppreference.com/w/}
\end{frame}

\begin{frame}
\frametitle{“共性”和“差异”}
在设计类的继承关系时，我们一般会将\textbf{功能相近，有共同属性但又不完全相同}的一些类设计成同一个基类的不同子类。
将它们的“共性”定义为基类的成员，
“差异”定义为子类的成员。

本题中的非线性方程求解器的共性是什么？
三个求解器的唯一共性就是它们均要求解一个一元函数的零点，其他参数均不同。

因此可以考虑将这个一元函数作为基类的成员，而其他参数
（例如二分法的$a,b,\delta,\epsilon,M$）作为子类的成员。
\end{frame}

\begin{frame}
\frametitle{函数类}
对其他参数，我们用 \lstinline|int, double| 等常规类型即可输入和存储。
但如何将一个函数\textbf{作为参数}传到求解器中？

我们在《C程序设计专题》课程中学习过函数指针的概念。
可以将函数在测试程序中定义好，然后用函数指针传进求解器中。

但函数指针的结构过于简单，无法表示同一类的函数（例如：所有$n$次多项式）
或者高度关联的函数（例如：函数与它的导数）。
因此我们一般会定义一个\textbf{函数类}。
\end{frame}

\begin{frame}[fragile]
\frametitle{函数类}
例如下面我们定义了一个函数基类，然后定义了它的一个子类并进行实例化。
\begin{lstlisting}[language=c++]
    class Function {
    public:
        virtual double operator() (double x) const = 0;
        virtual double derivative(double x) const {...}
    };
    class F1 : public Function {
    public:
        virtual double operator() (double x) const {...}
    };
\end{lstlisting}

思考：如何定义多项式函数类？这个问题在第 2 章编程作业中将至关重要。
\end{frame}

\begin{frame}[fragile]
\frametitle{求解器类示例代码}
\begin{lstlisting}[language=c++]
class EquationSolver{
protected:
    const Function & F;
public:
    EquationSolver(const Function& F) : F(F) {}
    virtual double solve() = 0;
};

class Bisection_Method : public EquationSolver {
private:
    double a, b;
    double eps, delta;
    int Maxiter;
public:
    Bisection_Method(const Function &F, double a, double b, 
        double eps = 1e-7, double delta = 1e-6, int Maxiter = 50) :
        EquationSolver(F), a(a), b(b), eps(eps), delta(delta), Maxiter(Maxiter) {}
    
    virtual double solve() {...}
};
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Problem-B 示例代码}
\begin{lstlisting}
#include "Function.hpp"
#include "EquationSolver.hpp"
#include <iostream>
#include <cmath>

const double Pi = acos(-1.);

class F1 : public Function {
public:
    double operator() (double x) const {
        return 1.0/x-tan(x);
    }
};

void solve_f1() {
    std::cout << "Solving x^{-1} - \\tan x on [0, \\pi/2]" << std::endl;
    Bisection_Method solver_f1(F1(), 0, Pi/2);
    double x = solver_f1.solve();
    std::cout << "A root is: " << x << std::endl;
}

/* Type your code here */

int main() {
    solve_f1();
    /* Type your code here */
    return 0;
}
\end{lstlisting}
\end{frame}

\end{document}